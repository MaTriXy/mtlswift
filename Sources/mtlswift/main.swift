import Clang
import cclang
import Foundation

/// Runs the specified program at the provided path.
/// - parameter path: The full path of the executable you
///                   wish to run.
/// - parameter args: The arguments you wish to pass to the
///                   process.
/// - returns: The standard output of the process, or nil if it was empty.
func run(_ path: String, args: [String] = []) -> String? {
    let pipe = Pipe()
    let process = Process()
    process.launchPath = path
    process.arguments = args
    process.standardOutput = pipe
    process.launch()
    process.waitUntilExit()
    
    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    guard let result = String(data: data, encoding: .utf8)?
        .trimmingCharacters(in: .whitespacesAndNewlines),
        !result.isEmpty else { return nil }
    return result
}

/// Finds the location of the provided binary on your system.
func which(_ name: String) -> String? {
    return run("/usr/bin/which", args: [name])
}

extension String: Error {
    /// Replaces all occurrences of characters in the provided set with
    /// the provided string.
    func replacing(charactersIn characterSet: CharacterSet,
                   with separator: String) -> String {
        let components = self.components(separatedBy: characterSet)
        return components.joined(separator: separator)
    }
}

public extension String {
    var extractingLevel: (Int, String) {
        var level = 0
        var trimmedSelf = self
        while true {
            if ["|-", "`-", "| ", "  "].contains(where: { trimmedSelf.hasPrefix($0) }) {
                trimmedSelf.removeFirst(2)
                level += 1
                continue
            }
            
            break
        }
        
        return (level, trimmedSelf)
    }
}

do {
    let path = CommandLine.arguments[1]
    
    guard path.hasSuffix(".metal") else {
        throw "You have to provide metal files"
    }
    
    let astPath = URL(fileURLWithPath: CommandLine.arguments[1]).deletingLastPathComponent().appendingPathComponent("ast").appendingPathExtension("dump")
    
    _ = run(which("rm")!, args: [astPath.path])
    _ = run(which("touch")!, args: [astPath.path])
    let outputHandle = try FileHandle(forUpdating: astPath)
    let process = Process()
    process.launchPath = which("xcrun")!
    process.arguments = ["-sdk", "iphoneos",
                         "metal",
                         "-Xclang", "-ast-dump",
                         "-Xclang", "-finclude-default-header",
                         "-E",
                         "-Xclang", "-fno-color-diagnostics",
                         "-fno-color-diagnostics",
                         path]
    process.standardOutput = outputHandle
    process.launch()
    process.waitUntilExit()
    
    outputHandle.synchronizeFile()
    outputHandle.seek(toFileOffset: 0)
    
    let data = outputHandle.readDataToEndOfFile()
    
    guard let result = String(data: data, encoding: .utf8)?
        .trimmingCharacters(in: .whitespacesAndNewlines),
        !result.isEmpty else { throw "" }
    let lines = result.components(separatedBy: .newlines)
    
    let firstLine = lines.first!.extractingLevel
    var currentLevel = firstLine.0
    
    let topNode = try ASTNode(parsingString: firstLine.1)
    var node = topNode
    for line in lines.dropFirst() {
        let extractingLevel = line.extractingLevel
        
        while currentLevel >= extractingLevel.0 {
            // TODO: Do something more clever
            guard node.parent != nil else {
                break
            }
            node = node.parent!
            currentLevel -= 1
        }
        
        guard extractingLevel.1 != "<<<NULL>>>" else {
            continue
        }
        
        let newChild = try ASTNode(parsingString: extractingLevel.1)
        newChild.parent = node
        node.children.append(newChild)
        node = newChild
        currentLevel = extractingLevel.0
    }
    
    let shaders = topNode.extractMetalShaders()
    //shaders.forEach { print($0.description) }
    let builder = SourceStringBuilder()
    builder.begin()
    builder.add(line: "// This file is autogenerated, do not edit it")
    builder.add(line: "import Alloy")
    builder.add(line: "")
    for shader in shaders {
        shader.generateSwiftSource(in: builder)
    }
    
    let filepath = URL(fileURLWithPath: CommandLine.arguments[1]).appendingPathExtension("swift")
    try builder.result.write(to: filepath,
                             atomically: true,
                             encoding: .utf8)
    
    let unit =
        try TranslationUnit(clangSource: String(contentsOfFile: path),
                            language: .cPlusPlus,
                            index: Index(excludeDeclarationsFromPCH: false,
                                         displayDiagnostics: false),
                            commandLineArgs: [],
                            options: [.skipFunctionBodies, .keepGoing])

    let commentTokens = unit.tokens(in: unit.cursor.range).enumerated()
                            .filter { $0.1 is CommentToken }
    
    let directiveTokens = commentTokens.filter { (arg: (offset: Int, element: Token)) -> Bool in
        return arg.element.spelling(in: unit).contains("mtlswift")
    }
    
    let sourceLocations = directiveTokens.map { $0.1 }.map { $0.location(in: unit).line }
    print(sourceLocations)
    
} catch {
    print(error.localizedDescription)
}
